import{d as z,s as b,o as L,Y as $,x as q,Z as N,$ as G,k as R,a0 as I,a as V,a1 as y,a2 as W,a3 as Y,H as Z,a4 as E,a5 as S,r as p,a6 as J,a7 as Q,a8 as X,M as x,a9 as K}from"./Dh5-9yFB.js";const k={trailing:!0};function A(a,e=25,u={}){if(u={...k,...u},!Number.isFinite(e))throw new TypeError("Expected `wait` to be a finite number");let r,t,c=[],n,h;const o=(f,l)=>(n=aa(a,f,l),n.finally(()=>{if(n=null,u.trailing&&h&&!t){const m=o(f,h);return h=null,m}}),n);return function(...f){return n?(u.trailing&&(h=f),n):new Promise(l=>{const m=!t&&u.leading;clearTimeout(t),t=setTimeout(()=>{t=null;const _=u.leading?r:o(this,f);for(const v of c)v(_);c=[]},e),m?(r=o(this,f),l(r)):c.push(l)})}}async function aa(a,e,u){return await a.apply(e,u)}const M=Symbol.for("nuxt:client-only"),ua=z({name:"ClientOnly",inheritAttrs:!1,props:["fallback","placeholder","placeholderTag","fallbackTag"],setup(a,{slots:e,attrs:u}){const r=b(!1);L(()=>{r.value=!0});const t=N();return t&&(t._nuxtClientOnly=!0),G(M,!0),()=>{var o;if(r.value){const f=(o=e.default)==null?void 0:o.call(e);return f&&f.length===1?[$(f[0],u)]:f}const c=e.fallback||e.placeholder;if(c)return c();const n=a.fallback||a.placeholder||"",h=a.fallbackTag||a.placeholderTag||"span";return q(h,u,n)}}}),ea=a=>a==="defer"||a===!1;function ta(...a){var v;const e=typeof a[a.length-1]=="string"?a.pop():void 0;na(a[0],a[1])&&a.unshift(e);let[u,r,t={}]=a;const c=R(()=>I(u));if(typeof c.value!="string")throw new TypeError("[nuxt] [useAsyncData] key must be a string.");if(typeof r!="function")throw new TypeError("[nuxt] [useAsyncData] handler must be a function.");const n=V();t.server??(t.server=!0),t.default??(t.default=ra),t.getCachedData??(t.getCachedData=j),t.lazy??(t.lazy=!1),t.immediate??(t.immediate=!0),t.deep??(t.deep=y.deep),t.dedupe??(t.dedupe="cancel"),t._functionName,n._asyncData[c.value];const h={cause:"initial",dedupe:t.dedupe};(v=n._asyncData[c.value])!=null&&v._init||(h.cachedData=t.getCachedData(c.value,n,{cause:"initial"}),n._asyncData[c.value]=B(n,c.value,r,t,h.cachedData));const o=n._asyncData[c.value];o._deps++;const f=()=>n._asyncData[c.value].execute(h),l=t.server!==!1&&n.payload.serverRendered;{let s=function(d){const D=n._asyncData[d];D!=null&&D._deps&&(D._deps--,D._deps===0&&(D==null||D._off()))};const i=N();if(i&&l&&t.immediate&&!i.sp&&(i.sp=[]),i&&!i._nuxtOnBeforeMountCbs){i._nuxtOnBeforeMountCbs=[];const d=i._nuxtOnBeforeMountCbs;W(()=>{d.forEach(D=>{D()}),d.splice(0,d.length)}),Y(()=>d.splice(0,d.length))}const C=i&&(i._nuxtClientOnly||Z(M,!1));l&&n.isHydrating&&(o.error.value||o.data.value!=null)?(o.pending.value=!1,o.status.value=o.error.value?"error":"success"):i&&(!C&&n.payload.serverRendered&&n.isHydrating||t.lazy)&&t.immediate?i._nuxtOnBeforeMountCbs.push(f):t.immediate&&f();const w=K();if(t.watch){const d=E(t.watch,()=>{o._execute({cause:"watch",dedupe:t.dedupe})},{flush:"post"});w&&S(()=>d())}const F=E(c,(d,D)=>{var O,T;const U=((O=n._asyncData[D])==null?void 0:O.data.value)!==y.value;D&&s(D);const P={cause:"initial",dedupe:t.dedupe};(T=n._asyncData[d])!=null&&T._init||(P.cachedData=t.getCachedData(d,n,{cause:"initial"}),n._asyncData[d]=B(n,d,r,t,P.cachedData)),n._asyncData[d]._deps++,(t.immediate||U)&&n._asyncData[d].execute(P)},{flush:"sync"});w&&S(()=>{F(),s(c.value)})}const m={data:g(()=>{var s;return(s=n._asyncData[c.value])==null?void 0:s.data}),pending:g(()=>{var s;return(s=n._asyncData[c.value])==null?void 0:s.pending}),status:g(()=>{var s;return(s=n._asyncData[c.value])==null?void 0:s.status}),error:g(()=>{var s;return(s=n._asyncData[c.value])==null?void 0:s.error}),refresh:(...s)=>n._asyncData[c.value].execute(...s),execute:(...s)=>n._asyncData[c.value].execute(...s),clear:()=>H(n,c.value)},_=Promise.resolve(n._asyncDataPromises[c.value]).then(()=>m);return Object.assign(_,m),_}function g(a){return R({get(){var e;return(e=a())==null?void 0:e.value},set(e){const u=a();u&&(u.value=e)}})}function na(a,e){return!(typeof a=="string"||typeof a=="object"&&a!==null||typeof a=="function"&&typeof e=="function")}function H(a,e){e in a.payload.data&&(a.payload.data[e]=void 0),e in a.payload._errors&&(a.payload._errors[e]=y.errorValue),a._asyncData[e]&&(a._asyncData[e].data.value=void 0,a._asyncData[e].error.value=y.errorValue,a._asyncData[e].pending.value=!1,a._asyncData[e].status.value="idle"),e in a._asyncDataPromises&&(a._asyncDataPromises[e]&&(a._asyncDataPromises[e].cancelled=!0),a._asyncDataPromises[e]=void 0)}function sa(a,e){const u={};for(const r of e)u[r]=a[r];return u}function B(a,e,u,r,t){var m;(m=a.payload._errors)[e]??(m[e]=y.errorValue);const c=r.getCachedData!==j,n=u,h=r.deep?p:b,o=t!=null,f=a.hook("app:data:refresh",async _=>{(!_||_.includes(e))&&await l.execute({cause:"refresh:hook"})}),l={data:h(o?t:r.default()),pending:b(!o),error:J(a.payload._errors,e),status:b("idle"),execute:(_={})=>{if(a._asyncDataPromises[e]){if(ea(_.dedupe??r.dedupe))return a._asyncDataPromises[e];a._asyncDataPromises[e].cancelled=!0}if(_.cause==="initial"||a.isHydrating){const s="cachedData"in _?_.cachedData:r.getCachedData(e,a,{cause:_.cause??"refresh:manual"});if(s!=null)return a.payload.data[e]=l.data.value=s,l.error.value=y.errorValue,l.status.value="success",Promise.resolve(s)}l.pending.value=!0,l.status.value="pending";const v=new Promise((s,i)=>{try{s(n(a))}catch(C){i(C)}}).then(async s=>{if(v.cancelled)return a._asyncDataPromises[e];let i=s;r.transform&&(i=await r.transform(s)),r.pick&&(i=sa(i,r.pick)),a.payload.data[e]=i,l.data.value=i,l.error.value=y.errorValue,l.status.value="success"}).catch(s=>{if(v.cancelled)return a._asyncDataPromises[e];l.error.value=X(s),l.data.value=x(r.default()),l.status.value="error"}).finally(()=>{v.cancelled||(l.pending.value=!1,delete a._asyncDataPromises[e])});return a._asyncDataPromises[e]=v,a._asyncDataPromises[e]},_execute:A((..._)=>l.execute(..._),0,{leading:!0}),_default:r.default,_deps:0,_init:!0,_hash:void 0,_off:()=>{f(),l._init=!1,c||Q(()=>{l._init||(H(a,e),l.execute=()=>Promise.resolve(),l.data.value=y.value)})}};return l}const ra=()=>y.value,j=(a,e,u)=>{if(e.isHydrating)return e.payload.data[a];if(u.cause!=="refresh:manual"&&u.cause!=="refresh:hook")return e.static.data[a]},ca=()=>V().$supabase.client,ia=(a=100)=>{const e=ca();return ta("frames",async()=>{const{data:u,error:r}=await e.from("images").select("*").eq("deleted",0).order("id",{ascending:!1}).limit(a);return r?[]:u})};export{ua as _,ia as a,ca as u};
